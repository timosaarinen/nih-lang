#!/usr/bin/env nih
(let WIDTH 16)   ; output width in characters
(let HEIGHT 16)  ; output height in characters

#define neg negate
# The above is a preprocessor/lexer directive! But this line is a comment, because there is whitespace at start. #pragmas don't. 

#  To-the-end-of-line comment ..short. Must have at least one whitespace after '#', otherwise #pragma.
;  To-the-end-of-line comment ..might also underline that no terminator character in the language?
// To-the-end-of-line comment ..too many options? Nah, depends on aesthetic preference (and IDE makes it irrelevant anyway).
/* Nestable block comments /* ..repeat, nested comments, for QoL */ */

//------------------------------------------------------------------------
//  Mandelbrot
//------------------------------------------------------------------------
(let mandelbrot
  (fn (plist (param c :vec2) 
             (returns :int (doc "# of iterations, 0 if not in Mandelbrot set"))
             (doc """
Calculates the number of iterations required to determine whether a given 
point \( c = c_x + c_yi \) in the complex plane is part of the Mandelbrot set.
            
In the Mandelbrot set, for each point c = c_x + c_y<i>, iterate function Z_n+1 = z^2_n + c starting from z_0 = 0 and
determine whether the sequence remains bounded. If the magnitude of Z_n exceeds 2 at any iteration, the sequence will
escape to infinity, and the point c is not in the Mandelbrot set. The number of iterations before this escape is what
we typically visualize in Mandelbrot set images.
             """))
  (let maxiters 99)                    ; maxiters = 99        ; '=' is immutable equality
  (set! z (call :vec2 0 0))            ; z := vec2(0.0, 0.0)  ; constructor syntax (GLSL-like vector types, but not as strict)
  (set! n 0)                           ; n := 0               ; ':=' is mutable assignment (no pre-declaration required)
  (do-while (                          ; do {
    (let px (- (^ z.x 2) (^ z.y 2)))   ;    px = z.x^2 - z.y^2
    (let py (*        -2 (* z.x z.y))) ;    py = -2*z.x*zy
    (let p (call :vec2 px py)          ;    p = vec2(px, py)
    (set! z (+ p c))                   ;    z := p + c
    (let d (call length z))            ;    d = length(z)     ; == sqrt( z.x^2, z.y^2 ) == (call sqrt (+ (^ zx 2) (^ zy 2)))
    (inc! n)                           ;    n++
    (if (> d 2) (return 0.0))          ;    if (d > 2) return 0
  ) (< n maxiters))                    ; } while(n < maxiters)
  (return n))                          ; return n

//------------------------------------------------------------------------
//  Mandelbrot with no vector types
//------------------------------------------------------------------------
(let mandelbrot0 
  (fn (plist 
    (param cx :float) 
    (param cy :float)
    (returns :int (doc "# of iterations, 0 if not in Mandelbrot set")))
  (let maxiters 80)
  (set! zx 0)
  (set! zy 0)
  (set! n 0)
  (do-while (
    (let px (- (^ zx 2) (^ zy 2)))
    (let py (- (* 2 zx zy)))
    (set! zx (+ px cx))
    (set! zy (+ py cy))
    (let d (call sqrt (+ (^ zx 2) (^ zy 2))))
    (inc! n)
    (if (> d 2) (return 0.0))
  ) (< n maxiters))
  (return n)))

//------------------------------------------------------------------------
//  Main
//------------------------------------------------------------------------
(call print (call mandelbrot0 0 0)) ; Test the two parameter version (int -> string in print macro)
(call print '----')

(let rs -2.0)
(let re 1.0)
(let is -1.0)
(let ie 1.0)

(for ((let y (range 0 HEIGHT))    ; NOTE: order matters, y is outer loop here
      (let x (range 0 WIDTH)))    ; Ranges have non-inclusive end
  (fn (plist (param y) (param x)) ; TODO: useful blocks-as-closures uniformity or useless middle step?
    (let c (vec2 (+ rs (* (/ x (cast WIDTH :float)) (- re rs)))
                 (+ is (* (/ y (cast HEIGHT :float)) (- ie is)))))
    (let m (call mandelbrot c))
    (call printchars (? (> m 0.0) '*' ' '))
    (call printlf)))


/*
//------------------------------------------------------------------------
//  "In your language how do you make something of the type map<k,v> 
//   and how do you make an instance of that type"
//
//  ..this is from the top of my head for now, mind! i.e. conceptual
//------------------------------------------------------------------------

type Map = [:K] :V[] ; Map = (key :K) -> value :V.. nope, the state/object/bits-in-the-machine, the array

:Map newmap(K :type, V :type)
  ; ..build a mapping K value -> V value
  ; - usually hashmap etc
  ; - but let's just do simple linear array:
  maparr := [:K] :V[]     ; TODO: not sure about this syntax..
  return maparr

//:Map mapadd(maparr :Map, K: type, V: type, key: K, value: V)  ; K/V don't need to be passed, take from the passed Map type
:Map mapadd(maparr :Map, key: K, value: V)
  return maparr.push([key, value])

:V mapget(maparr: Map, key: K)
  for x in maparr: if x.0 == key return x.1 ; .0 and .1 to access the first and second index of an array or tuple
  fatalerror 'No key $key found in this map! Exiting to DOS.'

/* OT: Come on.. implement the damn nested comments! ..UPDATE: Hey, at last it works. */

*/ ; why you VSC/Textmate.. will NOT fix the grammar, it has regexps!
