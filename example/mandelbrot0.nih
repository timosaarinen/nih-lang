#!/usr/bin/env nih
(let WIDTH 16)
(let HEIGHT 16)

// C comments
/** THIS DOESN'T WORK IN LEXER /** ALSO MUST BE NESTED OR GO HOME */ */
# bashy comments
(let mandelbrot (fn (plist 
    (param c :vec2) 
    (returns :int (doc "# of iterations, 0 if not in Mandelbrot set"))
    (doc """Calculates the number of iterations required to determine whether a given 
            point \( c = c_x + c_yi \) in the complex plane is part of the Mandelbrot set.""")
  (let maxiters 99)                                           ; maxiters = 99           ; '=' is immutable equality
  (set! z (vec2 0 0))                                         ; z := vec2(0.0, 0.0)     ; constructor syntax (GLSL-like vector types, but not as strict)
  (set! n 0)                                                  ; n := 0                  ; ':=' is mutable assignment (no pre-declaration required)
  (do-while (                                                 ; do {
    (let p (vec2 (- (^ z.x 2) (^ z.y 2)) (* -2 (* z.x z.y)))) ;    p = vec2( z.x^2 - z.y^2, -2*z.x*zy )
    (set! z (+ p c))                                          ;    z = p + c
    (let d (call length z))                                   ;    d = length(z)        ; == sqrt( z.x^2, z.y^2 ) == (call sqrt (+ (^ zx 2) (^ zy 2)))
    (inc! n)                                                  ;    n++
    (if (> d 2) (return 0.0))                                 ;    if (d > 2) return 0
  ) (< n maxiters))                                           ; } while(n < maxiters)
  (return n))                                                 ; return n
  (doc """In the Mandelbrot set, for each point c = c_x + c_y<i>, iterate function Z_n+1 = z^2_n + c starting from z_0 = 0 and
          determine whether the sequence remains bounded. If the magnitude of Z_n exceeds 2 at any iteration, the sequence will
          escape to infinity, and the point c is not in the Mandelbrot set. The number of iterations before this escape is what
          we typically visualize in Mandelbrot set images.""")))

//------------------------------------------------------------------------
//  Mandelbrot with no vector types
//------------------------------------------------------------------------
(let mandelbrot0 (fn (plist 
    (param cx :float) 
    (param cy :float) 
    (returns :int (doc "# of iterations, 0 if not in Mandelbrot set")))
  (let maxiters 80)
  (set! zx 0)
  (set! zy 0)
  (set! n 0)
  (do-while (
    (let px (- (^ zx 2) (^ zy 2)))
    (let py (- (* 2 zx zy)))
    (set! zx (+ px cx))
    (set! zy (+ py cy))
    (let d (call sqrt (+ (^ zx 2) (^ zy 2))))
    (inc! n)
    (if (> d 2) (return 0.0))
  ) (< n maxiters))
  (return n)))

//------------------------------------------------------------------------
//  Main
//------------------------------------------------------------------------
(call print (call mandelbrot0 0 0)) ; Test the two parameter version (int -> string in print macro)

(let rs -2.0)
(let re 1.0)
(let is -1.0)
(let ie 1.0)

(for ((let y (range 0 HEIGHT))    ; NOTE: order matters, y is outer loop here
      (let x (range 0 WIDTH)))    ; Ranges have non-inclusive end
  (fn (plist (param y) (param x)) ; TODO: useful blocks-as-closures uniformity or useless middle step?
    (let c (vec2 (+ rs (* (/ x (cast WIDTH :float)) (- re rs)))
                 (+ is (* (/ y (cast HEIGHT :float)) (- ie is)))))
    (let m (call mandelbrot c))
    (call printchars (? (> m 0.0) '*' ' '))
    (call printlf)))


/*
//------------------------------------------------------------------------
//  "In your language how do you make something of the type map<k,v> 
//   and how do you make an instance of that type"
//
//  ..this is from the top of my head for now, mind! i.e. conceptual
//------------------------------------------------------------------------

type Map = [:K] :V[] ; Map = (key :K) -> value :V.. nope, the state/object/bits-in-the-machine, the array

:Map newmap(K :type, V :type)
  ; ..build a mapping K value -> V value
  ; - usually hashmap etc
  ; - but let's just do simple linear array:
  maparr := [:K] :V[]     ; TODO: not sure about this syntax..
  return maparr

//:Map mapadd(maparr :Map, K: type, V: type, key: K, value: V)  ; K/V don't need to be passed, take from the passed Map type
:Map mapadd(maparr :Map, key: K, value: V)
  return maparr.push([key, value])

:V mapget(maparr: Map, key: K)
  for x in maparr: if x.0 == key return x.1 ; .0 and .1 to access the first and second index of an array or tuple
  fatalerror 'No key $key found in this map! Exiting to DOS.'

/* OT: Come on.. implement the damn nested comments! */

*/ ; why you VSC/Textmate.. will NOT fix the grammar, it has regexps!
